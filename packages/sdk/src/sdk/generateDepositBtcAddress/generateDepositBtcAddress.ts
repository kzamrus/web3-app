import axios from 'axios';
import { IEnvParam } from '../../common/types/internalTypes';
import { TChainId } from '../../common/types/types';
import { getErrorMessage } from '../../common/utils/getErrorMessage';
import { getApiConfig } from '../apiConfig';
import { getChainNameById } from '../utils/getChainNameById';

/**
 * The address wich will be returned if the provided EVM address is sanctioned.
 */
export const SANCTIONED_ADDRESS = 'sanctioned_address';
const ADDRESS_URL = 'api/v1/address';
const SANCTIONS_MESSAGE = 'destination address is under sanctions';

interface IGenerateNewAddressResponse {
  address: string;
}

export interface IGenerateDepositBtcAddressParams extends IEnvParam {
  /**
   * The destination EVM user address where LBTC will be claimed.
   */
  address: string;
  /**
   * The destination chain ID where LBTC will be claimed.
   */
  chainId: TChainId;
  /**
   * The signature of the address. The signature is generated by signing the address using EVM wallet.
   */
  signature: string;
  /**
   * The referral ID.
   */
  referralId?: string;
}

/**
 * Generates a BTC deposit address.
 *
 * If the provided EVM address is sanctioned, the function will return the `SANCTIONED_ADDRESS`.
 *
 * @param {IGenerateDepositBtcAddressParams} params - The parameters for generating the deposit address.
 * @returns {Promise<string>} The generated deposit address.
 */
export async function generateDepositBtcAddress({
  address,
  chainId,
  signature,
  referralId,
  env,
}: IGenerateDepositBtcAddressParams): Promise<string> {
  const { baseApiUrl } = getApiConfig(env);
  const toChain = getChainNameById(chainId);

  const requestParams = {
    to_address: address,
    to_address_signature: signature,
    to_chain: toChain,
    referral_id: referralId,
    nonce: 0,
  };

  try {
    const { data } = await axios.post<IGenerateNewAddressResponse>(
      ADDRESS_URL,
      requestParams,
      { baseURL: baseApiUrl },
    );

    return data.address;
  } catch (error) {
    const errorMsg = getErrorMessage(error);

    if (isSanctioned(errorMsg)) {
      return SANCTIONED_ADDRESS;
    } else {
      throw new Error(errorMsg);
    }
  }
}

function isSanctioned(errorMsg: string): boolean {
  return !!errorMsg.includes(SANCTIONS_MESSAGE);
}
